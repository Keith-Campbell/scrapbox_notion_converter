# Python/Pandas メモ
Python/Pandas メモ

#Python #プログラミング



### Q1: 読み込んだPandas のデータフレームに対して列スライシングを行い、複数の連続する列を抽出する

A: `df.loc`を用いる

以下のようなデータフレーム`df`があったとする（以下でもこれを利用することがある）。

-	a	b	c	d

0	123	345	456	678

1	213	513	932	329

2	481	931	324	801

`df.loc[:, "a":"c"`とすると、a列からc列までを抽出してくれる



### Q2: データフレームを for 文で用いるとき

A: `df.itertuples()`を用いる

例えば、`for i in df.itertuples():`とした場合、`i`には各行のデータがオブジェとして格納されている。最初の行なら

`Pandas(Index=0, a=123, b=345, c=456, d=678)`

となる。注意点としては列名が日本語の場合、つまり全角の場合も文字列リテラルとして`"`で囲われないため、例えば、dfのb列の名前が「数値」という名前だった場合、参照するときは`i.数値`という形になる。

他にも for 文で似たような形でデータフレームの各行を参照できるメソッドはあるが、`itertuples()`が高速だという。しかし、速いとは言ってもそもそもデータフレーム型の変数を for ループで使う事自体かなり処理が遅い問題があるため、できるだけ避けたいところ。



### Q2': どうしても for ループを使うとき

## A: アトリビュート`to_dict()`を用いていったん辞書型に直す。

`df.to_dict(orient="records")`とすれば、`df`は辞書型に変換することが可能。

code:python

 df_dict = df.to_dict(orient="records")

 for i, elem in enumerate(df_dict):

 	# loop

 	# 必要あれば二重ループ

 	for j in elem.values():

 		# 2nd loop

としておけばよい（`orient~`を付けないとうまくいかない）。





### Q3: 複数の条件を満たす行のみを抽出したいとき

## A: 添え字の`[```にそのまま条件式を書き込む

たとえば、`df`の`b`列の値が500以上の列のみを抽出したいときは

`df[df["b" >= 500`

と書くことで0行目を取り除いた2つの行データフレームが返される。

次に、`df`の`b`列の値が500以上かつ`d`列の値が600以上のものを抽出したいとすると

`df[(df["b" >= 500) & (df["d" >= 600)`

と書けば、2行目のみが抽出される。

論理記号は通常のPythonと同様の仕様となっているが、否定だけは`not`ではなく`~`を使う点に注意する。



### Q4: 条件に一致する行番号を抽出するには

## A: `.index`を使う

Q3のように条件を指定した場合、一致する行のすべての列データが出力されるが、行番号のみ保存しておきたいときは後ろに`index`をつければよい。



### 辞書型はデフォルトでキーを返す

for ループで`tst = {"apple": 100, "banana":50, "orange":86}`という辞書を利用するとしよう。このとき、`for j in tst:`とかくと、`j`にはキーが格納されるようになっている。つまり、`j="apple", "banana", "orange"`となる。値を利用したいときは`for j in tst.values():`とする。

そうはいえども、普通は`for j in tst:`としても、`tst[j`で値は$O(1)で参照できるので問題ない（ハッシュテーブルを用いているため。実はリストの参照は線形探索なのでとても遅い、可能なら辞書型もしくは集合型を利用すると良い）。



### Q5: 一部の列で条件を満たすものを抽出

参考：https://qiita.com/kouki_tsuji/items/e53973715c4c5874e151





